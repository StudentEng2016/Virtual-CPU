/****************************************************************************/
// Author: Kirolous Frouk
// Date  : 4/10/2015
// File Name: cpu.c
// This file contains execute ,fetch ,is carry,set flags ,split,trace .zero all 
/*****************************************************************************/
#include "head.h"


/*
Prints all registers 
*/
void printReg()
{
	int i=0;
	for (i=0;i<6;i++){
		printf("r0%d:%08lx ",i,reg[i]);}
	printf("\n");
	for (i=6;i<12;i++){
		printf("r%02d:%08lx ",i,reg[i]);}

	printf("\nr12:%08lx ",reg[12]);
	printf("\n");

	printf("SP: %08lx ", sp);printf(" LR: %08lx ",lr);printf(" PC: %08lx ",pc);

	printf("\t \tSZC:%1d%1d%1d\n",sign,zero,carry);
	printf("MBR:%08lx ",MBR);printf("MAR:%08lx ",MAR);printf("STOP:%1d ",stop);printf("IR_flag:%1d ",ir_flag);printf("IR: %08x\n",IR);




} 

/*
Fetches the coreect instruction 
Also toggles the ir flag 
and executes
*/
void fetch(void *memptr){ 
	int i;
	MAR = pc;
	pc = pc+sizeof(IR0);
	if(ir_flag==1)
	{
		execute(IR1);
		ir_flag=0;
		return;
	}

	for(i=0;i<4;i++)//gets 2 instructions 
	{
		MBR = MBR << 8;
		MBR += *((unsigned char *) memptr +(MAR++)); 
	}
	IR = MBR;
	split();// Splits the Ir reginste in to IR0 and IR1
	if(ir_flag==0)
	{
		ir_flag=1;
		execute(IR0);

	}


}
/*
Splits the ir register
*/
void split()
{
	IR0 = (IR>>16);
	IR1 = IR&IR1_MASK;
}
/*
Single steps throught the program
*/ 
void trace(){
	fetch(memory);
	printReg();//Prints the registers 

}
/*
Resets the cpu 
*/ 
void zeroAll(){
	int i;
	for(i=0;i<16;i++)
	{
		reg[i]=0;
	}
	IR0=0;
	//Memory Buffer Register - buffer for all data
	MBR = 0;
	//Memory Address Register - Holds memory address
	MAR =0;
	//Stop flag
	stop =unset;
	//IR active flag
	ir_flag =unset;
	//	CCR	- Condition Codes - Sign, Zero and Carry flags
	sign=unset;
	zero=unset;
	carry=unset;

	sp=0x4000 ;//seting the stack pointer to the top of the stack
}

/*
Executes the coreect instruction 
*/ 
void execute(uint16_t inst)
{
	if(isStop(inst)) //Stop Instruction
	{
		stop=1;
	}
	else if (isUnCond(inst))//Unconditional Branch 
	{
		ir_flag =unset;//resets ir since we may have loaded in an instruction before the branch
		unConditional(inst);
	}
	else if (isPP(inst))//Push pull instruction
	{
		pushPull(inst);
	}
	else if (isConditional(inst))//Conditional Branch 
	{
		ir_flag =unset;//resets ir since we may have loaded in an instruction before the branch
		conditional(inst);
	}
	else if((isIM(inst)))//Immediate instruction
	{
		immediate(inst);
	}
	else if (isLS(inst))
	{
		loadstore( inst);//Load store Instruction
	}
	else if(isData(inst))//Data instruction
	{
		data(inst);
	}
	return;
}



/**********************************************************
iscarry()- determine if carry is generated by addition: op1+op2+C
C can only have value of 1 or 0.
***********************************************************/
int iscarry(unsigned long op1,unsigned long op2){
	if ((op2 == MAX32)&&(carry == 1)) 
		return(1); // special case where op2 is at MAX32
	return((op1 > (MAX32 - op2 - carry))?1:0);
}

/*
Sets all the flags 
uses op1 and op2 to check carry and uses the alu to check sign and zero
*/
void set_flags(uint32_t op1, uint32_t op2)
{
	carry=unset;
	zero=unset;
	sign=unset;

	if(IS_SIGN(alu))
		sign=1;
	else
		sign=0;

	if(iscarry (op1, op2) == 1){
		carry=1;}
	else
		carry=0;

	if(IS_0(alu))
		zero=1;
	else
		zero=0;

	return;
}
/*
Sets sign zero flags 
uses the alu to check sign and zero
*/
void set_sz_flags()
{
	zero=unset;
	sign=unset;


	if(IS_SIGN(alu))
		sign=1;
	else
		sign=0;

	if(IS_0(alu))
		zero=1;
	else
		zero=0;

	return;
}
